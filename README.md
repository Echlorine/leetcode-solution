# leetcode-solution
A brief introduction to leetcode problems.  
Last Updated: 2022.07.05

**谨以此repo献给我的女朋友**，以及为了拿到心仪的offer一直不断拼搏的小伙伴。  
[面试索引](./Interview/Interview.md)根据面试考察的不同模块的知识进行了索引，让你准备更有针对性。  
[面试中出现的算法题](./Interview/leetcode.md)记录了面试中出现过的算法题。  
`find_problem.sh`是一个小脚本，可以根据题号判断你是否做过这道题了。  

## Data Structures and Algorithms(持续更新)
* [Sort](./Data%20Structure%20and%20Algorithm/Sort/Sort.md): 总结了常见的排序算法
* [DFS](./Data%20Structure%20and%20Algorithm/DFS/DFS与回溯.md): 深度优先遍历，适用于找到所有可能的解。可能会遇到超时的问题，这时候可以考虑动态规划。
* [DP](./Data%20Structure%20and%20Algorithm/Dynamic_programming.md): 重点在于状态的建模以及状态转移方程的建立
* [Greedy](./Data%20Structure%20and%20Algorithm/Greedy.md): 重点在于知道如何贪心，需要一定的经验
* [Disjoint_Set](./Data%20Structure%20and%20Algorithm/Disjoint_Set.md): 并查集，用于处理一些不相交集合的合并及查询问题
  
## Shell  
力扣上`Shell`编程题不算多，可以点击[这里](./Shell/Shell.md)查看。应对笔试/面试，更多还是要学习相应数据结构与算法的知识。 

## MySQL
`MySQL`的题目直接学习[专项突破「SQL」](https://leetcode.cn/study-plan/sql/)，可以点击[这里](./MySQL/MySQL.md)查看。

## 力扣题库及其考察的知识点(持续更新):  
题目名称|考察知识点|说明|关联题型|答案
:------|:--------|:---|:-------|:-:
[1. 两数之和](https://leetcode.cn/problems/two-sum/)|哈希表|Hash的思想：将键与值匹配，实现快速查找的效果|170|[Java](Java/Solution1.java)
[2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)|链表遍历|~|~|[Java](Java/Solution2.java)
[3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)|滑动窗口、**(前后)双指针**|~|76|[Java](Java/Solution2.java)
[4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)|二分查找|~|~|[Java](Java/Solution4.java)
[5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)|(字符串的)动态规划|这类动态规划题只能多练习掌握|10, 647|[Java](Java/Solution5.java)
[6. Z 字形变换](https://leetcode.cn/problems/zigzag-conversion/)|模拟|数学模拟，很朴素的思想|~|[Java](Java/Solution6.java)
[7. 整数反转](https://leetcode.cn/problems/reverse-integer/)|模拟|~|~|[Python](./Python/7.py)
[8. 字符串转换整数 (atoi)](https://leetcode.cn/problems/string-to-integer-atoi/)|**自动机**|很难想到的一个方法，编译原理里面的|~|[Java](Java/Solution8.java)
[9. 回文数](https://leetcode.cn/problems/palindrome-number/)|模拟|~|~|[Python](./Python/9.py)
[10. 正则表达式匹配](https://leetcode.cn/problems/regular-expression-matching/)|(字符串的)动态规划|只能多练找感觉|~|[Java](Java/Solution10.java)
[11. 盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/)|双指针模拟|~|~|[Java](Java/Solution11.java)
[12. 整数转罗马数字](https://leetcode.cn/problems/integer-to-roman/)|模拟|~|13|[Java](Java/Solution12.java)
[13. 罗马数字转整数](https://leetcode.cn/problems/roman-to-integer/)|模拟|~|12|[Java](Java/Solution13.java) [Python](./Python/13.py)
[14. 最长公共前缀](https://leetcode.cn/problems/longest-common-prefix/)|**分治**，横向扫描、纵向扫描|掌握分治的思想|~|[Python](./Python/14.py)
[15. 三数之和](https://leetcode.cn/problems/3sum/)|双指针|利用排序和双指针减少一次遍历|16, 18|[Java](Java/Solution15.java) [Python](./Python/15.py)
[16. 最接近的三数之和](https://leetcode.cn/problems/3sum-closest/)|双指针|~|15, 18|[Java](Java/Solution16.java)
[17. 电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/solution/)|回溯|回溯方法很适合遍历找到所有解|46|[Java](Java/Solution17.java)
[18. 四数之和](https://leetcode.cn/problems/4sum/)|双指针|~|15, 16|[Java](Java/Solution18.java)
[19. 删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)|(前后)双指针|前后双指针的一个很巧妙的应用|~|[Java](Java/Solution19.java)
[20. 有效的括号](https://leetcode.cn/problems/valid-parentheses/)|栈|括号匹配的一个很经典的例子，用栈来实现|22, 32, 224, 394|[Python](./Python/20.py)
[21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)|递归、迭代|这道题的迭代也很经典|23|[Java](Java/Solution21.java) [Python](./Python/21.py)
[22. 括号生成](https://leetcode.cn/problems/generate-parentheses/)|回溯|~|20, 32|[Java](Java/Solution22.java)
[23. 合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)|分治、优先队列|**优先队列笔试挺喜欢考的**|21|[Java](Java/Solution23.java)
[24. 两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)|迭代、递归|迭代更容易想到|~|[Java](Java/Solution24.java)
[25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/)|递归|思路是模拟，实现用递归或者迭代|24, 206|[Java](Java/Solution25.java)
[26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)|(快慢)双指针|~|27, 80|[Java](Java/Solution26.java) [Python](./Python/26.py)
[27. 移除元素](https://leetcode.cn/problems/remove-element/)|(快慢)双指针|~|26, 88|[Java](Java/Solution27.java) [Python](./Python/27.py)
[28. 实现 strStr()](https://leetcode.cn/problems/implement-strstr/)|KMP算法|KMP算法是字符串匹配的经典算法，Python的find函数背后就是KMP|~|[Python](./Python/28.py)
[29. 两数相除](https://leetcode.cn/problems/divide-two-integers/)|二分法|~|~|[Java](Java/Solution29.java)
[31. 下一个排列](https://leetcode.cn/problems/next-permutation/)|扫描|思路不太容易想，但看了题解又觉得思想很朴素|~|[Java](Java/Solution31.java)
[32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)|动态规划|好几个括号题，但是思路都不一样|20, 22|[Java](Java/Solution32.java)
[33. 搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)|二分查找|二分查找适合有序表的查找|34, 35, 81|[Java](Java/Solution33.java)
[34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)|二分查找|~|33, 35|[Java](Java/Solution34.java)
[35. 搜索插入位置](https://leetcode.cn/problems/search-insert-position/)|二分查找|一道不错的训练二分查找的题目|33, 34|[Python](./Python/35.py)
[36. 有效的数独](https://leetcode.cn/problems/valid-sudoku/)|~|难点在于数独行与列的表示|37|[Java](Java/Solution36.java)
[37. 解数独](https://leetcode.cn/problems/sudoku-solver/)|回溯|~|36|[Java](Java/Solution37.java)
[38. 外观数列](https://leetcode.cn/problems/count-and-say/)|模拟|答案二是面向测试用例编程|~|[Java](Java/Solution38.java)
[39. 组合总和](https://leetcode.cn/problems/combination-sum/)|回溯|~|~|[Java](Java/Solution39.java)
[40. 组合总和 II](https://leetcode.cn/problems/combination-sum-ii/)|回溯|需要剪枝|78|[Java](Java/Solution40.java)
[41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)|~|~|287, 442, 448|[Java](Java/Solution41.java)
[42. 接雨水](https://leetcode.cn/problems/trapping-rain-water/)|动态规划，双指针|模拟也能解决问题|~|[Java](Java/Solution42.java)
[43. 字符串相乘](https://leetcode.cn/problems/multiply-strings/solution/)|~|字符串的加法与乘法，有时候用这种方法解决溢出问题|415|[Java](Java/Solution43.java)
[45. 跳跃游戏 II](https://leetcode.cn/problems/jump-game-ii/)|贪心|每一步选择将来跳的远的格子|55|[Java](Java/Solution45.java)
[46. 全排列](https://leetcode.cn/problems/permutations/)|回溯|~|17, 77, 78|[Java](Java/Solution46.java) [Python](./Python/46.py)
[47. 全排列 II](https://leetcode.cn/problems/permutations-ii/)|回溯|~|40, 46, 60|[Java](Java/Solution47.java)
[48. 旋转图像](https://leetcode.cn/problems/rotate-image/)|模拟|有技巧的模拟|~|[Java](Java/Solution48.java)
[49. 字母异位词分组](https://leetcode.cn/problems/group-anagrams/)|计数，Hash|手动编写 Hash 函数的难点在于解决哈希冲突|1, 438, 567|[Java](Java/Solution49.java)
[50. Pow(x, n)](https://leetcode.cn/problems/powx-n/)|快速幂算法|分治思想，同时了解迭代思想背后的数学原理|~|[Java](Java/Solution50.java)
[51. N 皇后](https://leetcode.cn/problems/n-queens/)|回溯|学会使用位运算剪枝|52|[Java](Java/Solution51.java)
[52. N皇后 II](https://leetcode.cn/problems/n-queens-ii/)|回溯|学会使用位运算剪枝|51|[Java](Java/Solution52.java)
[53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)|动态规划|这道题也可以利用线段树来做|~|[Java](Java/Solution53.java) [Python](./Python/53.py)
[54. 螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)|模拟，DFS|本质是遍历|2061|[Java](Java/Solution54.java)
[55. 跳跃游戏](https://leetcode.cn/problems/jump-game/)|贪心，动态规划|贪心时间复杂度$O(n)$，动态规划时间复杂度$O({n^2})$|45|[Java](Java/Solution55.java)
[56. 合并区间](https://leetcode.cn/problems/merge-intervals/)|贪心，排序|~|~|[Java](Java/Solution56.java)
[57. 插入区间](https://leetcode.cn/problems/insert-interval/)|模拟|~|56|[Java](Java/Solution57.java)
[58. 最后一个单词的长度](https://leetcode.cn/problems/length-of-last-word/)|遍历|此题没什么难度|~|[Python](./Python/58.py)
[59. 螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/)|模拟|~|54|[Java](Java/Solution59.java)
[60. 排列序列](https://leetcode.cn/problems/permutation-sequence/)|回溯|全排列的题目|46, 47|[Java](Java/Solution60.java)
[61. 旋转链表](https://leetcode.cn/problems/rotate-list/)|双指针|~|~|[Java](Java/Solution61.java)
[62. 不同路径](https://leetcode.cn/problems/unique-paths/)|DFS，动态规划|DFS会超时，用动态规划|63, 64|[Java](Java/Solution62.java)
[63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)|DFS，动态规划|DFS会超时，用动态规划|62, 64|[Java](Java/Solution63.java)
[64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)|动态规划|~|62, 63|[Java](Java/Solution64.java)
[66. 加一](https://leetcode.cn/problems/plus-one/)|模拟|~|~|[Python](./Python/66.py)
[67. 二进制求和](https://leetcode.cn/problems/add-binary/)|位运算，模拟|模拟补位这个思想特挺好想的，位运算需要一定技巧，最好也掌握|137, 260, 421, 187, 318|[Python](./Python/67.py)
[68. 文本左右对齐](https://leetcode.cn/problems/text-justification/)|贪心|贪心体现在每一行的单词尽可能的多|~|[Java](Java/Solution68.java)
[69. x 的平方根](https://leetcode.cn/problems/sqrtx/)|模拟|牛顿迭代法是一个不错的方法，C语言课堂上也是这么教的|~|[Python](./Python/69.py)
[70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)|动态规划，递归|经典的递归题目，直接递归重复计算太多超时|509|[Python](./Python/70.py)
[71. 简化路径](https://leetcode.cn/problems/simplify-path/)|栈|先根据有效 / 拆分路径，简化问题|224, 394|[Java](Java/Solution71.java)
[72. 编辑距离](https://leetcode.cn/problems/edit-distance/)|动态规划|挺不好理解的|~|[Java](Java/Solution72.java)
[73. 矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)|模拟|利用数组自身的空间存储状态信息，节省空间|~|[Java](Java/Solution73.java)
[74. 搜索二维矩阵](https://leetcode.cn/problems/search-a-2d-matrix/)|二分查找|~|240|[Java](Java/Solution74.java)
[75. 颜色分类](https://leetcode.cn/problems/sort-colors/)|双指针|用指针进行模拟更简单一些|~|[Java](Java/Solution75.java)
[76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)|滑动窗口|~|3|[Java](Java/Solution76.java)
[77. 组合](https://leetcode.cn/problems/combinations/)|回溯|有着不同的考虑问题的思路|78, 216|[Java](Java/Solution77.java)
[78. 子集](https://leetcode.cn/problems/subsets/)|回溯|和46题一样，是一道经典的回溯问题|46, 77|[Java](Java/Solution78.java)
[79. 单词搜索](https://leetcode.cn/problems/word-search/)|DFS|~|62, 63, 64, 200|[Java](Java/Solution79.java)
[80. 删除有序数组中的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/)|双指针|~|26|[Java](Java/Solution80.java)
[81. 搜索旋转排序数组 II](https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/)|二分查找|~|33|[Java](Java/Solution81.java)
[82. 删除排序链表中的重复元素 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)|模拟|~|83|[Java](Java/Solution82.java)
[83. 删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list/)|模拟|~|82|[Java](Java/Solution83.java)
[84. 柱状图中最大的矩形](https://leetcode.cn/problems/largest-rectangle-in-histogram/)|单调栈|思路比较容易想，但是**单调栈**这种数据结构不一定会应用|85|[Java](Java/Solution84.java)
[85. 最大矩形](https://leetcode.cn/problems/maximal-rectangle/)|单调栈|本质和84题居然相同，思路不太容易想|84|[Java](Java/Solution85.java)
[86. 分隔链表](https://leetcode.cn/problems/partition-list/)|链表|链表题利用虚结点可以简化问题|~|[Java](Java/Solution86.java)
[88. 合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/)|双指针|~|26, 27|[Python](./Python/88.py)
[89. 格雷编码](https://leetcode.cn/problems/gray-code/)|回溯，位运算|根据生成[公式](https://baike.baidu.com/item/%E6%A0%BC%E9%9B%B7%E7%A0%81#5)也可以直接生成|~|[Java](Java/Solution89.java)
[90. 子集 II](https://leetcode.cn/problems/subsets-ii/)|回溯|掌握二进制枚举这种思路|77, 78|[Java](Java/Solution90.java)
[91. 解码方法](https://leetcode.cn/problems/decode-ways/)|动态规划|分情况讨论的状态转移|~|[Java](Java/Solution91.java)
[92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/submissions/)|递归|~|25, 206|[Java](Java/Solution92.java)
[93. 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)|回溯|利用IP特征，3层for循环是一个很朴素的思路|~|[Java](Java/Solution93.java)
[94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)|二叉树的遍历|二叉树的先根、中根、后根遍历本质都是DFS|98, 101|[Java](Java/Solution94.java)
[95. 不同的二叉搜索树 II](https://leetcode.cn/problems/unique-binary-search-trees-ii/)|递归|树的问题，优先选择递归|~|[Java](Java/Solution95.java)
[96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)|动态规划，卡塔兰数|题目本质为知道中根遍历的结果，一共有多少种可能的二叉树。[卡塔兰数](https://baike.baidu.com/item/catalan/7605685)的应用|~|[Java](Java/Solution96.java)
[98. 验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/solution/)|中根遍历|二叉搜索树的中根遍历结果是**递增**的|94, 99|[Java](Java/Solution98.java)
[99. 恢复二叉搜索树](https://leetcode.cn/problems/recover-binary-search-tree/)|中根遍历|找出交换的位置|94, 98|[Java](Java/Solution99.java)
[100. 相同的树](https://leetcode.cn/problems/same-tree/)|递归|也可以遍历|~|[Java](Java/Solution100.java)
[101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)|二叉树的遍历|二叉树遍历的主要方法：直接**递归**、用**栈**模拟递归|94, 98|[Java](Java/Solution101.java)
[102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)|二叉树的层次遍历|层次遍历的本质是**BFS**|~|[Java](Java/Solution102.java)
[104. 二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)|递归，DFS，BFS|还是喜欢递归的思路|111, 257|[Java](Java/Solution104.java)
[105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)|利用先根遍历和中根遍历|配上Hash可以省去查找的时间|106, 1008, 1028|[Java](Java/Solution105.java)
[106. 从中序与后序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)|掌握后根遍历和中根遍历|~|105, 1008, 1028|[Java](Java/Solution106.java)
[108. 将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)|递归|高度平衡二叉搜索树|109|[Java](Java/Solution108.java)
[109. 有序链表转换二叉搜索树](https://leetcode.cn/problems/convert-sorted-list-to-binary-search-tree/)|递归|高度平衡二叉搜索树，快速找链表的中间结点|108, 876|[ava](Java/Solution109.java)
[111. 二叉树的最小深度](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)|递归|可以采用DFS遍历并实时更新最短路径|104, 257|[Java](Java/Solution111.java)
[113. 路径总和 II](https://leetcode.cn/problems/path-sum-ii/)|DFS|树的遍历，递归思路|~|[Java](Java/Solution113.java)
[114. 二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)|先根遍历|这道题的思路有很多，个人还是喜欢递归，毕竟树的问题，一般都用递归解决|~|[Java](Java/Solution114.java)
[115. 不同的子序列](https://leetcode.cn/problems/distinct-subsequences/)|动态规划|双串的动态规划|~|[Java](Java/Solution115.java)
[118. 杨辉三角](https://leetcode.cn/problems/pascals-triangle/)|模拟|根据规律计算出来即可|119|[Java](Java/Solution118.java)
[119. 杨辉三角 II](https://leetcode.cn/problems/pascals-triangle-ii/)|模拟|倒着计算更新时不影响值的计算|118|[Java](Java/Solution119.java)
[120. 三角形最小路径和](https://leetcode.cn/problems/triangle/)|动态规划|经典的动态规划题，可以从上往下，也可以从下往上|~|[Java](Java/Solution120.java)
[121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)|~|本质是动态规划|53, 122, 309|[Java](Java/Solution121.java)
[122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)|动态规划，贪心|多状态动态规划|309, 714|[Java](Java/Solution122.java)
[123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)|动态规划|通解是利用多状态动态规划，也可以分为2部分，每部分都用[121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)的方法|121, 122, 309|[Java](Java/Solution123.java)
[124. 二叉树中的最大路径和](https://leetcode.cn/problems/binary-tree-maximum-path-sum/)|递归|这道题比较巧妙的地方在于每次递归的返回值和我们最终的结果有联系，但是不是同一个东西|~|[Java](Java/Solution124.java)
[125. 验证回文串](https://leetcode.cn/problems/valid-palindrome/)|双指针|掌握转换大小写字符的API|151, 680|[Java](Java/Solution125.java)
[128. 最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)|Hash，[并查集](https://zhuanlan.zhihu.com/p/468711675)|查找型问题，利用Hash可以降低时间复杂度|1|[Java](Java/Solution128.java)
[129. 求根节点到叶节点数字之和](https://leetcode.cn/problems/sum-root-to-leaf-numbers/)|树的遍历|DFS, BFS|~|[Java](Java/Solution129.java)
[130. 被围绕的区域](https://leetcode.cn/problems/surrounded-regions/)|DFS，BFS，并查集|本质是岛屿类问题，经典的DFS问题|695, 1020|[Java](Java/Solution130.java)
[131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)|回溯|~|~|[Java](Java/Solution131.java)
[133. 克隆图](https://leetcode.cn/problems/clone-graph/)|图的遍历|考察了图的表示以及遍历|~|[Java](Java/Solution133.java)
[134. 加油站](https://leetcode.cn/problems/gas-station/)|贪心|本质还是模拟|~|[Java](Java/Solution134.java)
[135. 分发糖果](https://leetcode.cn/problems/candy/)|贪心|在满足要求的情况下，每个孩子分到的糖果尽可能少|~|[Java](Java/Solution135.java)
[136. 只出现一次的数字](https://leetcode.cn/problems/single-number/)|位运算|异或运算满足交换律和结合律，异或运算也是一种常见的哈希函数|49|[Java](Java/Solution136.java)
[139. 单词拆分](https://leetcode.cn/problems/word-break/)|动态规划|看到题目就会想到用动态规划来实现，不过状态转移方程不太好想|~|[Java](Java/Solution139.java)
[141. 环形链表](https://leetcode.cn/problems/linked-list-cycle/)|(快慢)双指针|这道题也可以当成查找已经访问的结点，用Hash做|26, 27, 88|[Java](Java/Solution141.java)
[142. 环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)|(快慢)双指针|此处有重要的数学结论：环内相遇点到入环点的距离等于起点到入环点的距离|141, 287|[Java](Java/Solution142.java)
[143. 重排链表](https://leetcode.cn/problems/reorder-list/)|~|一道链表的综合题，解题思路较多|206, 876|[Java](Java/Solution143.java)
[144. 二叉树的前序遍历](https://leetcode.cn/problems/binary-tree-preorder-traversal/)|遍历|二叉树的遍历|94, 145|[Java](Java/Solution144.java)
[145. 二叉树的后序遍历](https://leetcode.cn/problems/binary-tree-postorder-traversal/)|遍历|二叉树的遍历|94, 144|[Java](Java/Solution145.java)
[146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)|Hash，链表|要求查找和更新操作都要常数时间复杂度。因此需要兼具`Hash`和`链表`的特征|~|[Java](Java/Solution146.java)
[148. 排序链表](https://leetcode.cn/problems/sort-list/)|归并排序|时间复杂度$O({n\log_2n})$|~|[Java](Java/Solution148.java)
[151. 颠倒字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)|双指针|熟悉字符串的相关API|125|[Java](Java/Solution151.java)
[152. 乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/)|动态规划|一下子维护了两个dp数组|53|[Java](Java/Solution152.java)
[155. 最小栈](https://leetcode.cn/problems/min-stack/)|辅助栈|官方题解是通过辅助栈来实现一个最小栈的结构，额外空间复杂度大，而且有点取巧的感觉，建议用所给代码解法解决，空间复杂度为常数|~|[Java](Java/Solution155.java)
[157. 用 Read4 读取 N 个字符](https://leetcode.cn/problems/read-n-characters-given-read4/)|模拟|理解题意，模拟即可|~|[Java](Java/Solution157.java)
[159. 至多包含两个不同字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-most-two-distinct-characters/)|滑动窗口|~|340|[Java](Java/Solution159.java)
[160. 相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)|Hash，数学|这道题的数学没见过类似题型的话，不太好想|~|[Java](Java/Solution160.java)
[161. 相隔为 1 的编辑距离](https://leetcode.cn/problems/one-edit-distance/)|模拟|分类讨论解决问题|~|[Java](Java/Solution161.java)
[162. 寻找峰值](https://leetcode.cn/problems/find-peak-element/)|二分查找|本质是二分查找，不过需要讨论的情况多了点|~|[Java](Java/Solution162.java)
[163. 缺失的区间](https://leetcode.cn/problems/missing-ranges/)|遍历数组|模拟，注意边界即可|~|[Java](Java/Solution163.java)
[165. 比较版本号](https://leetcode.cn/problems/compare-version-numbers/)|双指针|题目不难，主要考察了字符串表示的数比大小|415|[Java](Java/Solution165.java)
[167. 两数之和 II - 输入有序数组](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted/)|二分查找，双指针|双指针更利用了有序数组的性质|15, 18|[Java](Java/Solution167.java)
[168. Excel表列名称](https://leetcode.cn/problems/excel-sheet-column-title/)|模拟|10进制与26进制的转换，注意细节就好|~|[Java](Java/Solution168.java)
[169. 多数元素](https://leetcode.cn/problems/majority-element/)|哈希表，**Boyer-Moore 投票算法**|~|~|[Java](Java/Solution169.java)
[170. 两数之和 III - 数据结构设计](https://leetcode.cn/problems/two-sum-iii-data-structure-design/)|Hash|~|1|[Java](Java/Solution170.java)
[179. 最大数](https://leetcode.cn/problems/largest-number/)|排序|字符串比较|~|[Java](Java/Solution179.java)
[186. 翻转字符串里的单词 II](https://leetcode.cn/problems/reverse-words-in-a-string-ii/)|双指针|~|151|[Java](Java/Solution186.java)
[188. 买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)|动态规划|~|123|[Java](.Java/Solution188.java)
[189. 轮转数组](https://leetcode.cn/problems/rotate-array/)|双指针|掌握环状方法以及数组翻转的方法|~|[Java](Java/Solution189.java)
[198. 打家劫舍](https://leetcode.cn/problems/house-robber/)|动态规划|利用**滚动数组**可以降低空间复杂度|~|[Java](Java/Solution198.java)
[199. 二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)|二叉树的遍历|DFS遍历需要记录最大层数，BFS遍历需要判断是不是最右边的结点|~|[Java](Java/Solution199.java)
[200. 岛屿数量](https://leetcode.cn/problems/number-of-islands/)|DFS，BFS，并查集|岛屿类问题|130, 694, 695|[Java](Java/Solution200.java)
[202. 快乐数](https://leetcode.cn/problems/happy-number/)|Hash，(快慢)双指针|掌握Hash和快慢双指针的思想。找规律也能很快做出来，甚至可以直接利用计算10次之后看结果是否为1进行判断|~|[Java](Java/Solution202.java)
[203. 移除链表元素](https://leetcode.cn/problems/remove-linked-list-elements/)|链表遍历|注意考虑特殊情况|~|[Java](Java/Solution203.java)
[206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)|递归、迭代|~|~|[Java](Java/Solution206.java)
[207. 课程表](https://leetcode.cn/problems/course-schedule/)|拓扑排序|图的相关知识，必须要会|210, 802|[Java](Java/Solution207.java)
[208. 实现 Trie (前缀树)](https://leetcode.cn/problems/implement-trie-prefix-tree/)|前缀树|学习前缀树这个模型，可能会对其他字符串类型的题提供解决思路|~|[Java](Java/Solution208.java)
[209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/)|前缀和，滑动窗口|经典的滑动窗口的题目|219|[Java](Java/Solution209.java)
[210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/)|拓扑排序|掌握正向的拓扑排序和逆向的拓扑排序|207, 802|[Java](Java/Solution210.java)
[213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)|动态规划|分为两种情况讨论|198|[Java](Java/Solution213.java)
[215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)|选择排序|快速排序、堆排序|~|[Java](Java/Solution215.java)
[216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/)|回溯|剪枝进一步优化时间|77|[Java](Java/Solution216.java)
[217. 存在重复元素](https://leetcode.cn/problems/contains-duplicate/)|哈希表|此题进一步优化，只要哈希表中存在当前值即可返回真|~|[Java](Java/Solution217.java)
[219. 存在重复元素 II](https://leetcode.cn/problems/contains-duplicate-ii/)|滑动窗口，哈希表|利用哈希表存储下标最大值也是一个好方法|209|[Java](Java/Solution219.java)
[221. 最大正方形](https://leetcode.cn/problems/maximal-square/)|动态规划|重点还是找到状态以及建立状态转移方程|1277|[Java](Java/Solution221.java)
[224. 基本计算器](https://leetcode.cn/problems/basic-calculator/)|栈|用栈模拟括号匹配|20, 227, 394|[Java](Java/Solution224.java)
[225. 用队列实现栈](https://leetcode.cn/problems/implement-stack-using-queues/)|栈，队列|思考如何用一个队列实现|232|[Java](Java/Solution225.java)
[226. 翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)|递归|遇到二叉树最先想到的就应该是递归|101|[Java](Java/Solution226.java) [Python](./Python/226.py)
[227. 基本计算器 II](https://leetcode.cn/problems/basic-calculator-ii/)|栈|用栈模拟运算符的优先级|224|[Java](Java/Solution227.java)
[232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)|队列，栈|~|225|[Java](Java/Solution232.java)
[234. 回文链表](https://leetcode.cn/problems/palindrome-linked-list/)|递归、快慢指针|这道题的递归方法可以更好的了解递归的作用机理|206|[Java](Java/Solution234.java)
[236. 二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)|递归、哈希|对于有一一对应关系的数据存在，就应该想到哈希表|~|[Java](Java/Solution236.java)
[237. 删除链表中的节点](https://leetcode.cn/problems/delete-node-in-a-linked-list/)|链表|理解题意，根据基本的链表操作即可|~|[Java](Java/Solution237.java)
[238. 除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)|左右乘积列表|学习一下这个思想|~|[Java](Java/Solution238.java)
[239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)|优先队列|~|253|[Java](Java/Solution239.java)
[240. 搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)|二分查找、Z 字形查找|Z 字形查找比二分查找更充分的利用矩阵的特点|74|[Java](Java/Solution240.java)
[246. 中心对称数](https://leetcode.cn/problems/strobogrammatic-number/)|双指针|注意特殊情况处理|~|[Java](Java/Solution246.java)
[250. 统计同值子树](https://leetcode.cn/problems/count-univalue-subtrees/)|动态规划，DFS|树形的动态规划|298, 549, 687|[Java](Java/Solution250.java)
[252. 会议室](https://leetcode.cn/problems/meeting-rooms/)|快速优先排序|快排是时间复杂度较低的排序算法|253|[Java](Java/Solution252.java)
[253. 会议室 II](https://leetcode.cn/problems/meeting-rooms-ii/)|优先队列|`Java`中`PriorityQueue`是利用二叉堆实现的[优先队列](https://blog.csdn.net/lcore/article/details/9100073)|~|[Java](Java/Solution253.java)
[256. 粉刷房子](https://leetcode.cn/problems/paint-house/)|动态规划|多状态动态规划|265|[Java](Java/Solution256.java)
[257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)|回溯|树的深度优先遍历|104, 111|[Java](Java/Solution257.java)
[265. 粉刷房子 II](https://leetcode.cn/problems/paint-house-ii/)|动态规划|~|256|[Java](Java/Solution265.java)
[278. 第一个错误的版本](https://leetcode.cn/problems/first-bad-version/)|二分查找|~|~|[Java](Java/Solution278.java)
[279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)|动态规划|这题属于完全背包问题|322,2212|[Java](Java/Solution279.java) [Python](./Python/279.py)
[283. 移动零](https://leetcode.cn/problems/move-zeroes/)|双指针|此题有简易解法|27|[Java](Java/Solution283.java)
[287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/)|二分查找，快慢指针|二分查找主要是问题的转化，知道自己需要找什么；快慢指针难点在于将数组转化为链表结构|142|[Java](Java/Solution287.java)
[297. 二叉树的序列化与反序列化](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)|二叉树的遍历|序列化与反序列化的关键在于空结点的存储|1028|[Java](Java/Solution297.java)
[298. 二叉树最长连续序列](https://leetcode.cn/problems/binary-tree-longest-consecutive-sequence/)|动态规划，DFS|树形的动态规划|337, 549|[Java](Java/Solution298.java)
[300. 最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)|动态规划，贪心|~|435|[Java](Java/Solution300.java)
[301. 删除无效的括号](https://leetcode.cn/problems/remove-invalid-parentheses/)|DFS, BFS|此题使用DFS难在问题的建模|20, 22|[Java](Java/Solution301.java)
[305. 岛屿数量 II](https://leetcode.cn/problems/number-of-islands-ii/)|并查集|确定连通分量的数量是并查集的典型应用|547|[Java](Java/Solution305.java)
[306. 累加数](https://leetcode.cn/problems/additive-number/)|回溯|难在问题的转化以及处理数据溢出|2|[Java](Java/Solution306.java)
[309. 最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/)|动态规划|这道题的状态也需要好好构思一下|121, 122, 123, 188, 714|[Java](Java/Solution309.java)
[312. 戳气球](https://leetcode.cn/problems/burst-balloons/)|动态规划|题目难点在于状态的建立和转移|~|[Java](Java/Solution312.java) [Python](./Python/312.py)
[319. 灯泡开关](https://leetcode.cn/problems/bulb-switcher/)|数学|自己试几次也能发现规律|~|[Java](Java/Solution319.java)
[322. 零钱兑换](https://leetcode.cn/problems/coin-change/)|动态规划|完全背包问题|279|[Java](Java/Solution322.java)
[323. 无向图中连通分量的数目](https://leetcode.cn/problems/number-of-connected-components-in-an-undirected-graph/)|DFS|图的表示与遍历|207, 547|[Java](Java/Solution323.java)
[337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)|动态规划|树类型的动态规划和后序遍历结合起来用|298|[Java](Java/Solution337.java)
[338. 比特位计数](https://leetcode.cn/problems/counting-bits/)|动态规划|~|~|[Java](Java/Solution338.java) 
[340. 至多包含 K 个不同字符的最长子串](https://leetcode.cn/problems/longest-substring-with-at-most-k-distinct-characters/)|滑动窗口，哈希表|利用数组实现哈希表的功能|159, 438|[Java](Java/Solution340.java)
[343. 整数拆分](https://leetcode.cn/problems/integer-break/)|动态规划|利用数学方法分析可以进一步降低时间复杂度|~|[Java](Java/Solution343.java)
[344. 反转字符串](https://leetcode.cn/problems/reverse-string/)|双指针|双指针的简单应用|917|[Java](Java/Solution344.java)
[345. 反转字符串中的元音字母](https://leetcode.cn/problems/reverse-vowels-of-a-string/)|双指针|结合哈希表判断|~|[Java](Java/Sloution345.java)
[347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)|优先队列|要求时间复杂度优于$O({n\log_2n})$，不能简单进行`sort()`|253|[Java](Java/Solution347.java)
[349. 两个数组的交集](https://leetcode.cn/problems/intersection-of-two-arrays/)|哈希，双指针|利用哈希表进行空间换时间|350|[Java](Java/Solution349.java)
[350. 两个数组的交集 II](https://leetcode.cn/problems/intersection-of-two-arrays-ii/)|哈希，双指针|~|349|[Java](Java/Solution350.java)
[354. 俄罗斯套娃信封问题](https://leetcode.cn/problems/russian-doll-envelopes/)|动态规划|本质是LIS问题|300, 673, 406|[Java](Java/Solution354.java)
[357. 统计各位数字都不同的数字个数](https://leetcode.cn/problems/count-numbers-with-unique-digits/)|排列组合|这是一道数学问题|~|[Java](Java/Solution357.java)
[366. 寻找二叉树的叶子节点](https://leetcode.cn/problems/find-leaves-of-binary-tree/)|树的遍历|先根遍历就是自上而下删除叶子结点，后根遍历就是自下而上判断子树的高度|~|[Java](Java/Solution366.java)
[368. 最大整除子集](https://leetcode.cn/problems/largest-divisible-subset/)|动态规划|先排序，简化问题|~|[Java](Java/Solution368.java)
[370. 区间加法](https://leetcode.cn/problems/range-addition/)|差分数组|利用前缀和的思想，需要借鉴和掌握|~|[Java](Java/Solution370.java)
[376. 摆动序列](https://leetcode.cn/problems/wiggle-subsequence/)|贪心，动态规划|动态规划选择不同的状态，时间复杂度也不同|~|[Java](Java/Solution376.java)
[380. O(1) 时间插入、删除和获取随机元素](https://leetcode.cn/problems/insert-delete-getrandom-o1/)|集合|熟悉Java集合的常见操作|~|[Java](Java/Solution380.java)
[382. 链表随机节点](https://leetcode.cn/problems/linked-list-random-node/)|水塘抽样|在未知链表长度时就用水塘抽样，当随机取得一个数的操作较多时，应用空间换时间|~|[Java](Java/Solution382.java)
[383. 赎金信](https://leetcode.cn/problems/ransom-note/)|计数|哈希|~|[Java](Java/Solution383.java)
[392. 判断子序列](https://leetcode.cn/problems/is-subsequence/)|贪心，双指针|贪心的思想体现在每次选择左边匹配的字符|~|[Java](Java/Solution392.java)
[394. 字符串解码](https://leetcode.cn/problems/decode-string/)|栈|括号匹配的问题|20, 224|[Java](Java/Solution394.java)
[399. 除法求值](https://leetcode.cn/problems/evaluate-division/)|带权并查集|带权并查集需要在查找及合并时更新权值|~|[Java](/Java/Solution399.java)
[400. 第 N 位数字](https://leetcode.cn/problems/nth-digit/)|数学模拟，二分查找|本利用先验知识确定边界解决溢出|~|[Java](Java/Solution400.java)
[402. 移掉 K 位数字](https://leetcode.cn/problems/remove-k-digits/)|贪心|每次删除较大的数|~|[Java](Java/Solution402.java)
[403. 青蛙过河](https://leetcode.cn/problems/frog-jump/)|动态规划|~|~|[Java](Java/Solution403.java)
[406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/)|排序|难点在于问题的转化|354|[Java](Java/Solution406.java)
[410. 分割数组的最大值](https://leetcode.cn/problems/split-array-largest-sum/submissions/)|动态规划|拆分连续数组的题目|813|[Java](Java/Solution410.java)
[413. 等差数列划分](https://leetcode.cn/problems/arithmetic-slices/)|动态规划|由于要求连续子数组，使得状态转移简单一些|~|[Java](Java/Solution413.java)
[415. 字符串相加](https://leetcode.cn/problems/add-strings/)|~|加法的一个技巧，对于溢出的情况很有用|43|[Java](Java/Solution415.java)
[416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)|动态规划|0-1背包问题|494, 1230|[Java](Java/Solution416.java)
[417. 太平洋大西洋水流问题](https://leetcode.cn/problems/pacific-atlantic-water-flow/)|回溯|本题通过反向搜索降低时间复杂度|~|[Java](Java/Solution417.java)
[424. 替换后的最长重复字符](https://leetcode.cn/problems/longest-repeating-character-replacement/)|滑动窗口|如果一个问题暂时没有思路，可以先考虑暴力解法|~|[Java](Java/Solution424.java)
[435. 无重叠区间](https://leetcode.cn/problems/non-overlapping-intervals/)|贪心，动态规划|~|300|[Java](Java/Solution435.java)
[437. 路径总和 III](https://leetcode.cn/problems/path-sum-iii/)|前缀和|利用树的递归遍历是一个首选思路|560|[Java](Java/Solution437.java)
[438. 找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)|滑动窗口|~|49, 567|[Java](Java/Solution438.java)
[448. 找到所有数组中消失的数字](https://leetcode.cn/problems/find-all-numbers-disappeared-in-an-array/)|~|~|155|[Java](Java/Solution448.java) 
[452. 用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)|贪心|此题排序时候注意溢出|~|[Java](Java/Solution452.java)
[455. 分发饼干](https://leetcode.cn/problems/assign-cookies/)|贪心|贪心的入门题|~|[Java](Java/Solution455.java)
[461. 汉明距离](https://leetcode.cn/problems/hamming-distance/)|位运算|题目本质就是统计一个数的二进制表示其中 1 的数目|338|[Java](Java/Solution461.java)
[473. 火柴拼正方形](https://leetcode.cn/problems/matchsticks-to-square/)|回溯|~|~|[Java](Java/Solution473.java)
[485. 最大连续 1 的个数](https://leetcode.cn/problems/max-consecutive-ones/)|模拟|一次遍历即可|~|[Java](Java/Solution485.java)
[487. 最大连续1的个数 II](https://leetcode.cn/problems/max-consecutive-ones-ii/)|滑动窗口|~|424, 1004|[Java](Java/Solution487.java)
[494. 目标和](https://leetcode.cn/problems/target-sum/)|动态规划|0-1背包问题|416, 1230|[Java](Java/Solution494.java)
[509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)|动态规划，递归|记忆化递归解决了递归重复计算的问题|70|[Java](Java/Solution509.java)
[518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-2/)|动态规划|完全背包问题|~|[Java](Java/Solution518.java)
[529. 扫雷游戏](https://leetcode.cn/problems/minesweeper/)|回溯|本质是岛屿类问题，特殊之处在于一次有8个方向可以遍历|~|[Java](Java/Solution529.java)
[538. 把二叉搜索树转换为累加树](https://leetcode.cn/problems/convert-bst-to-greater-tree/)|中根遍历|转化问题，就很好解决|94|[Java](Java/Solution538.java)
[540. 有序数组中的单一元素](https://leetcode.cn/problems/single-element-in-a-sorted-array/submissions/)|二分查找|先通过分析确定待查找下标的性质，从而确定如何二分查找|~|[Java](Java/Solution540.java)
[541. 反转字符串 II](https://leetcode.cn/problems/reverse-string-ii/)|双指针|~|344, 917|[Java](Java/Solution541.java)
[542. 01 矩阵](https://leetcode.cn/problems/01-matrix/)|BFS|本质是最短路径问题|~|[Java](Java/Solution542.java)
[543. 二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)|DFS|~|~|[Java](Java/Solution543.java)
[547. 省份数量](https://leetcode.cn/problems/number-of-provinces/)|DFS，并查集|题目本质就是确定图的连通分量的数量|323|[Java](Java/Solution547.java)
[549. 二叉树中最长的连续序列](https://leetcode.cn/problems/binary-tree-longest-consecutive-sequence-ii/)|动态规划，DFS|树形的动态规划|298, 337|[Java](Java/Solution549.java)
[557. 反转字符串中的单词 III](https://leetcode.cn/problems/reverse-words-in-a-string-iii/)|双指针|~|344, 541|[Java](Java/Solution557.java)
[560. 和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)|前缀和|~|437|[Java](Java/Solution560.java)
[561. 数组拆分 I](https://leetcode.cn/problems/array-partition-i/)|贪心，排序|贪心在于每次选择的数尽可能接近|~|[Java](Java/Solution561.java)
[567. 字符串的排列](https://leetcode.cn/problems/permutation-in-string/)|异位词，滑动窗口|利用计数的方法处理异位词|49, 438|[Java](Java/Solution567.java)
[572. 另一棵树的子树](https://leetcode.cn/problems/subtree-of-another-tree/)|树的遍历，哈希|树的序列化|652|[Java](Java/Solution572.java)
[581. 最短无序连续子数组](https://leetcode.cn/problems/shortest-unsorted-continuous-subarray/)|插入排序，双指针|无序数组中的最小值和最大值应该在的位置之间的长度即为答案|~|[Java](Java/Solution581.java)
[589. N 叉树的前序遍历](https://leetcode.cn/problems/n-ary-tree-preorder-traversal/)|树的前序遍历|掌握利用栈实现的思想|144|[Java](Java/Solution589.java)
[590. N 叉树的后序遍历](https://leetcode.cn/problems/n-ary-tree-postorder-traversal/)|树的后序遍历|掌握利用栈实现的思想|145|[Java](Java/Solution590.java)
[611. 有效三角形的个数](https://leetcode.cn/problems/valid-triangle-number/)|二分查找|利用双指针可以优化时间复杂度|~|[Java](Java/Solution611.java)
[617. 合并二叉树](https://leetcode.cn/problems/merge-two-binary-trees/)|递归|~|226|[Java](Java/Solution617.java)
[621. 任务调度器](https://leetcode.cn/problems/task-scheduler/)|模拟|~|~|[Java](Java/Solution621.java)
[633. 平方数之和](https://leetcode.cn/problems/sum-of-square-numbers/)|双指针|注意越界|~|[Java](Java/Solution633.java)
[643. 子数组最大平均数 I](https://leetcode.cn/problems/maximum-average-subarray-i/)|滑动窗口|每一次求和时，利用滑动窗口，更新降低时间复杂度|1252|[Java](Java/Solution643.java)
[647. 回文子串](https://leetcode.cn/problems/palindromic-substrings/)|中心扩展法|Manacher 算法不要求掌握|5|[Java](Java/Solution647.java)
[652. 寻找重复的子树](https://leetcode.cn/problems/find-duplicate-subtrees/)|二叉树的遍历|要想唯一确定二叉树，就需要序列化|572|[Java](Java/Solution652.java)
[673. 最长递增子序列的个数](https://leetcode.cn/problems/number-of-longest-increasing-subsequence/)|动态规划|一下子维护两个dp数组|~|[Java](Java/Solution673.java)
[674. 最长连续递增序列](https://leetcode.cn/problems/longest-continuous-increasing-subsequence/)|贪心，双指针|贪心体现在以某一个元素开头的子序列尽可能长|~|[Java](Java/Solution674.java)
[679. 24 点游戏](https://leetcode.cn/problems/24-game/)|回溯|这道题可以更好的理解回溯|~|[Java](Java/Solution679.java)
[680. 验证回文字符串 Ⅱ](https://leetcode.cn/problems/valid-palindrome-ii/)|双指针|~|125|[Java](Java/Solution680.java)
[684. 冗余连接](https://leetcode.cn/problems/redundant-connection/)|并查集|DFS也可以做|~|[Java](Java/Solution684.java)
[687. 最长同值路径](https://leetcode.cn/problems/longest-univalue-path/)|动态规划，DFS|树形的动态规划|250, 298, 549|[Java](Java/Solution687.java)
[694. 不同岛屿的数量](https://leetcode.cn/problems/number-of-distinct-islands/)|DFS|本质是岛屿类问题|200|[Java](Java/Solution694.java)
[695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/)|回溯|本质是岛屿类问题，经典的DFS问题|130, 200|[Java](Java/Solution695.java)
[698. 划分为k个相等的子集](https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/)|回溯|~|473|[Java](Java/Solution698.java)
[704. 二分查找](https://leetcode.cn/problems/binary-search/)|二分查找|必须会写|~|[Java](Java/Solution704.java)
[707. 设计链表](https://leetcode.cn/problems/design-linked-list/)|链表|熟悉链表的性质以及操作|~|[Java](Java/Solution707.java)
[714. 买卖股票的最佳时机含手续费](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)|动态规划|具有两个状态的动态规划|122|[Java](Java/Solution714.java)
[720. 词典中最长的单词](https://leetcode.cn/problems/longest-word-in-dictionary/)|哈希|涉及字符串字典序的比较，也可用字典树实现|208|[Java](Java/Solution720.java)
[738. 单调递增的数字](https://leetcode.cn/problems/monotone-increasing-digits/)|贪心|在满足要求时让每一位的数字尽可能大|~|[Java](Java/Solution738.java)
[739. 每日温度](https://leetcode.cn/problems/daily-temperatures/)|单调栈|如果需要找到左边或者右边第一个比当前位置的数大或者小，则可以考虑使用单调栈|84, 85|[Java](Java/Solution739.java)
[740. 删除并获得点数](https://leetcode.cn/problems/delete-and-earn/)|动态规划|问题的转化|198|[Java](Java/Solution740.java)
[746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)|动态规划|~|~|[Java](Java/Solution746.java)
[763. 划分字母区间](https://leetcode.cn/problems/partition-labels/)|贪心，哈希表|贪心每次所能到达的最远距离|~|[Java](Java/Solution763.java)
[765. 情侣牵手](https://leetcode.cn/problems/couples-holding-hands/)|并查集|确定并查集的连通分量数量比确定并查集内每一个连通分量的大小更容易|547|[Java](Java/Solution765.java)
[772. 基本计算器 III](https://leetcode.cn/problems/basic-calculator-iii/)|栈|逆波兰表达式|224, 227|[Java](Java/Solution772.java)
[780. 到达终点](https://leetcode.cn/problems/reaching-points/)|模拟|数学分析优化时间复杂度|~|[Java](Java/Solution780.java)
[784. 字母大小写全排列](https://leetcode.cn/problems/letter-case-permutation/)|回溯|~|~|[Java](Java/Solution784.java)
[785. 判断二分图](https://leetcode.cn/problems/is-graph-bipartite/)|DFS，并查集|~|802, 886|[Java](Java/Solution785.java)
[796. 旋转字符串](https://leetcode.cn/problems/rotate-string/)|~|本质是查找子串的题|28|[Java](Java/Solution796.java)
[802. 找到最终的安全状态](https://leetcode.cn/problems/find-eventual-safe-states/)|DFS，拓扑排序|标准的深度优先遍历|207, 210, 785|[Java](Java/Solution802.java)
[804. 唯一摩尔斯密码词](https://leetcode.cn/problems/unique-morse-code-words/)|哈希表|`Java`中直接利用数组实现 hash 比`HashMap`速度快一点点|1|[Java](Java/Solution804.java)
[806. 写字符串需要的行数](https://leetcode.cn/problems/number-of-lines-to-write-string/)|模拟|~|~|[Java](Java/Solution806.java)
[813. 最大平均值和的分组](https://leetcode.cn/problems/largest-sum-of-averages/)|动态规划|理解状态如何转移|410|[Java](Java/Solution813.java)
[852. 山脉数组的峰顶索引](https://leetcode.cn/problems/peak-index-in-a-mountain-array/)|二分查找|二分查找的简单应用|~|[Java](Java/Solution852.java)
[860. 柠檬水找零](https://leetcode.cn/problems/lemonade-change/)|贪心|本题贪心的是让5元的纸币数量尽可能多|~|[Java](Java/Solution860.java)
[861. 翻转矩阵后的得分](https://leetcode.cn/problems/score-after-flipping-matrix/)|贪心|就行而言，1的位置尽可能靠左；就列而言，1的数量尽可能多|~|[Java](Java/Solution861.java)
[873. 最长的斐波那契子序列的长度](https://leetcode.cn/problems/length-of-longest-fibonacci-subsequence/)|动态规划，哈希|~|300|[Java](Java/Solution873.java)
[876. 链表的中间结点](https://leetcode.cn/problems/middle-of-the-linked-list/)|(快慢)双指针|~|26, 27, 141, 142, 287|[Java](Java/Solution876.java)
[886. 可能的二分法](https://leetcode.cn/problems/possible-bipartition/)|DFS，并查集|深度优先遍历，但遍历时需要记录其它信息|785|[Java](Java/Solution886.java)
[887. 鸡蛋掉落](https://leetcode.cn/problems/super-egg-drop/)|动态规划|思考方式很奇特的动态规划|~|[Java](Java/Solution887.java)
[917. 仅仅反转字母](https://leetcode.cn/problems/reverse-only-letters/)|双指针|~|344|[Java](Java/Solution917.java)
[918. 环形子数组的最大和](https://leetcode.cn/problems/maximum-sum-circular-subarray/)|动态规划|难在环形数组的处理，将环形数组分为两部分处理|53|[Java](Java/Solution918.java)
[921. 使括号有效的最少添加](https://leetcode.cn/problems/minimum-add-to-make-parentheses-valid/)|贪心|贪心体现在对于每一个出现的右括号，前面必须保证有左括号与其匹配|~|[Java](Java/Solution921.java)
[975. 奇偶跳](https://leetcode.cn/problems/odd-even-jump/)|动态规划，单调栈|就状态转移而言，这道题不难，难点在于利用单调栈简化表示|84, 85|[Java](Java/Solution975.java)
[977. 有序数组的平方](https://leetcode.cn/problems/squares-of-a-sorted-array/)|双指针|练习双指针的一道不错的题目|~|[Java](Java/Solution977.java)
[978. 最长湍流子数组](https://leetcode.cn/problems/longest-turbulent-subarray/)|滑动窗口|注意相等的时候左右边界同时移动|~|[Java](Java/Solution978.java)
[990. 等式方程的可满足性](https://leetcode.cn/problems/satisfiability-of-equality-equations/)|并查集|本质是确定图的连通分量|547|[Java](Java/Solution990.java)
[995. K 连续位的最小翻转次数](https://leetcode.cn/problems/minimum-number-of-k-consecutive-bit-flips/)|差分数组|~|155|[Java](Java/Solution995.java)
[1004. 最大连续1的个数 III](https://leetcode.cn/problems/max-consecutive-ones-iii/)|滑动窗口|~|487|[Java](Java/Solution1004.java)
[1008. 前序遍历构造二叉搜索树](https://leetcode.cn/problems/construct-binary-search-tree-from-preorder-traversal/)|递归|构建二叉树的题目|105, 106, 1028|[Java](Java/Solution1008.java)
[1020. 飞地的数量](https://leetcode.cn/problems/number-of-enclaves/)|DFS，BFS，并查集|本质是岛屿类问题，经典的DFS问题|130, 695|[Java](Java/Solution1020.java)
[1027. 最长等差数列](https://leetcode.cn/problems/longest-arithmetic-subsequence/)|动态规划|~|873|[Java](Java/Solution1027.java)
[1028. 从先序遍历还原二叉树](https://leetcode.cn/problems/recover-a-tree-from-preorder-traversal/)|根据遍历结果还原二叉树|~|105, 106, 297, 1008|[Java](Java/Solution1028.java)
[1029. 两地调度](https://leetcode.cn/problems/two-city-scheduling/)|贪心|贪心体现在尽可能让*去B市费用与去A市费用*相差越大的人去A市，剩下的去B市|~|[Java](Java/Solution1029.java)
[1034. 边界着色](https://leetcode.cn/problems/coloring-a-border/)|回溯|本质是岛屿类问题|130, 200, 1020|[Java](Java/Solution1034.java)
[1052. 爱生气的书店老板](https://leetcode.cn/problems/grumpy-bookstore-owner/)|滑动窗口|~|643|[Java](Java/Solution1052.java)
[1079. 活字印刷](https://leetcode.cn/problems/letter-tile-possibilities/)|回溯|本质是树结构|~|[Java](Java/Solution1079.java)
[1102. 得分最高的路径](https://leetcode.cn/problems/path-with-maximum-minimum-value/)|并查集|并查集的巧妙运用|[Java](../Java/Solution1102.java)
[1136. 平行课程](https://leetcode.cn/problems/parallel-courses/)|拓扑排序|运用了关键活动算法中求每一个事件的最早开始时间|207, 210, 802|[Java](Java/Solution1136.java)
[1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)|动态规划|经典的双串动态规划|~|[Java](Java/Solution1143.java)
[1208. 尽可能使字符串相等](https://leetcode.cn/problems/get-equal-substrings-within-budget/)|滑动窗口|~|~|[Java](Java/Solution1208.java)
[1217. 玩筹码](https://leetcode.cn/problems/minimum-cost-to-move-chips-to-the-same-position/)|贪心|贪心的思想体现在尽可能多的移动偶数次|~|[Java](Java/Solution1217.java)
[1229. 安排会议日程](https://leetcode.cn/problems/meeting-scheduler/)|双指针|对不同情况进行讨论确定指针如何移动|~|[Java](Java/Solution1229.java)
[1230. 抛掷硬币](https://leetcode.cn/problems/toss-strange-coins/)|动态规划|0-1背包问题|416, 494|[Java](Java/Solution1230.java)
[1247. 交换字符使得字符串相同](https://leetcode.cn/problems/minimum-swaps-to-make-strings-equal/)|贪心|此题需要确定3类基本的字符串形式，贪心在于尽量让一次交换是的两个位置由不同变为相同|~|[Java](Java/Solution1247.java)
[1254. 统计封闭岛屿的数目](https://leetcode.cn/problems/number-of-closed-islands/)|回溯|岛屿问题的进阶，需要一些判断条件|200, 1020|[Java](Java/Solution1254.java)
[1306. 跳跃游戏 III](https://leetcode.cn/problems/jump-game-iii/)|BFS|一道简单的广度优先搜索题|~|[Java](Java/Solution1306.java)
[1319. 连通网络的操作次数](https://leetcode.cn/problems/number-of-operations-to-make-network-connected/)|并查集|实质还是确定连通分量的数量|547|[Java](Java/Solution1319.java)
[1332. 删除回文子序列](https://leetcode.cn/problems/remove-palindromic-subsequences/)|双指针|~|125|[Java](Java/Solution1332.java)
[1372. 二叉树中的最长交错路径](https://leetcode.cn/problems/longest-zigzag-path-in-a-binary-tree/)|动态规划，DFS|树形的动态规划|~|[Java](Java/Solution1372.java)
[1388. 3n 块披萨](https://leetcode.cn/problems/pizza-with-3n-slices/)|动态规划|~|213|[Java](Java/Solution1388.java)
[1400. 构造 K 个回文字符串](https://leetcode.cn/problems/construct-k-palindrome-strings/)|贪心|此题贪心在于让奇数个字符分配到不同的回文串中|~|[Java](Java/Solution1400.java)
[1423. 可获得的最大点数](https://leetcode.cn/problems/maximum-points-you-can-obtain-from-cards/)|滑动窗口|反向思考问题更简单|~|[Java](Java/Solution1423.java)
[1456. 定长子串中元音的最大数目](https://leetcode.cn/problems/maximum-number-of-vowels-in-a-substring-of-given-length/)|滑动窗口|~|1052|[Java](Java/Solution1456.java)
[1473. 粉刷房子 III](https://leetcode.cn/problems/paint-house-iii/)|动态规划|多状态动态规划|~|[Java](Java/Solution1473.java)
[1478. 安排邮筒](https://leetcode.cn/problems/allocate-mailboxes/)|动态规划|多维状态，同时需要进行数学分析|~|[Java](Java/Solution1478.java)
[1493. 删掉一个元素以后全为 1 的最长子数组](https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/)|滑动窗口|~|487|[Java](Java/Solution1493.java)
[1523. 在区间范围内统计奇数数目](https://leetcode.cn/problems/count-odd-numbers-in-an-interval-range/)|数学，前缀和|前缀和的方法本质也是数学|~|[Java](Java/Solution1523.java)
[1593. 拆分字符串使唯一子字符串的数目最大](https://leetcode.cn/problems/split-a-string-into-the-max-number-of-unique-substrings/)|回溯|~|~|[Java](Java/Solution1593.java)
[1603. 设计停车系统](https://leetcode.cn/problems/design-parking-system/)|模拟|很简单的一道题|~|[Java](Java/Solution1603.java)
[1605. 给定行和列的和求可行矩阵](https://leetcode.cn/problems/find-valid-matrix-given-row-and-column-sums/)|贪心|贪心体现在生成矩阵某一个位置的值的时候，让这个值尽可能大|~|[Java](Java/Solution1605.java)
[1658. 将 x 减到 0 的最小操作数](https://leetcode.cn/problems/minimum-operations-to-reduce-x-to-zero/)|滑动窗口|同时处理前缀和及后缀和会降低时间复杂度|~|[Java](Java/Solution1658.java)
[1695. 删除子数组的最大得分](https://leetcode.cn/problems/maximum-erasure-value/)|滑动窗口|配合哈希表处理右滑边界|~|[Java](Java/Solution1695.java)
[1710. 卡车上的最大单元数](https://leetcode.cn/problems/maximum-units-on-a-truck/)|贪心，排序|贪心体现在优先选择大箱子|~|[Java](Java/Solution1710.java)
[1984. 学生分数的最小差值](https://leetcode.cn/problems/minimum-difference-between-highest-and-lowest-of-k-scores/)|滑动窗口|本题将题目转化后就会好做很多|~|[Java](Java/Solution1984.java)
[2061. 扫地机器人清扫过的空间个数](https://leetcode.cn/problems/number-of-spaces-cleaning-robot-cleaned/)|模拟，DFS|本题难点在于确定遍历终止|54|[Java](Java/Solution2061.java)

## 剑指 Offer（第 2 版）题库及其考察的知识点(持续更新):  
题目名称|考察知识点|说明|关联题型|答案
:------|:--------|:---|:-------|:-:
[剑指 Offer 09. 用两个栈实现队列](https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/)|队列，栈|面试高频题|~|[Java](Java/Offer09.java)
[剑指 Offer 13. 机器人的运动范围](https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)|回溯|迷宫类问题，需要根据题意在遍历时判断|~|[Java](Java/Offer13.java)
[剑指 Offer 10- I. 斐波那契数列](https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/)|递归，迭代|递归和迭代正好是相反的过程|~|[Java](Java/Offer10_I.java)

## 程序员面试金典（第 6 版）题库及其考察的知识点(持续更新):  
题目名称|考察知识点|说明|关联题型|答案
:------|:--------|:---|:-------|:-:
[面试题 17.24. 最大子矩阵](https://leetcode.cn/problems/max-submatrix-lcci/)|动态规划|最大连续子序和|~|[Java](Java/Interview1724.java)