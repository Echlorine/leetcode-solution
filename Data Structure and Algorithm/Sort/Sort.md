# 插入排序
## [直接插入排序](./InsertSort.java)
基本思想：将一个记录插入到已排好序的有序表中，从而得到一个新的、记录数增1的有序表。  
改进：利用哨兵规避边界检测

## [希尔排序](./ShellSort.java)
Shell排序法是对直接插入算法的改进。把记录按下标的一定增量分组。

# 交换排序
## [冒泡排序](./BubbleSort.java)
基本思想：自下而上（或从左到右）比较相邻记录的关键词，交换存在逆序的记录(若$K_j$＞$K_{j+1}$，则互换$R_j$和$R_{j+1}$)；使关键词较大的记录如气泡一般逐渐往上“飘移”直至“水面”。  
改进：在每一趟比较中，当比较结束后，如果发现位置$t$是最后一次记录交换，即说明从$R_{t+1}$ ~ $R_n$已经排序，从而下一趟比较只要进行到位置$t$即可。这样可以减少算法的关键词比较次数。

## [快速排序](./QuickSort.java)
每一趟分划把一个记录放在最终的位置上。  
力扣相关题:  
[215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)
# 选择排序
## [直接选择排序](./SelectionSort.java)
基本思想：每次在未排序的序列中选最小的元素，并和首元素交换。

## [堆排序](./HeapSort.java)
**完全二叉树**中的任意结点的关键词大于等于（小于等于）它的两个子结点的关键词，这样的数据结构称为最大堆（最小堆），同时堆用数组来表示很方便。  
力扣相关题:  
[215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

# [合并排序](./MergeSort.java)
一种基于分治法的排序。  
力扣相关题:  
[21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)
[23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)
[148. 排序链表](https://leetcode-cn.com/problems/sort-list/)

# 桶排序
## 计数排序
## 桶排序
## 基数排序

更多内容可以参考[十大经典排序算法总结](https://www.runoob.com/w3cnote/ten-sorting-algorithm.html)

# 排序算法的度量指标:
## 时间开销(时间复杂性):
是衡量算法好坏的最重要标志。可用算法执行中关键词的比较次数与数据的移动次数来衡量。
## 空间复杂性:
主要考察排序过程占用存储空间的大小。
## 排序算法的**稳定性**:
如果两个对象$R_i$和$R_j$, 其关键词相同($R_i与R_j$值相同), 且在排序前$R_i$在$R_j$的前面，若排序后，$R_i$仍在$R_j$的前面，则称这个排序方法是稳定的，否则称这个排序方法是不稳定的。

# 基于关键词比较的排序算法分析
排序方法|最好时间|平均时间|最坏时间|辅助空间|稳定性
:-----:|:-----:|:------:|:------:|:-----:|:-:
直接插入|$O(n)$|$O(n^2)$|$O(n^2)$|$O(1)$|稳定
直接选择|$O(n^2)$|$O(n^2)$|$O(n^2)$|$O(1)$|不稳定
冒泡|$O(n)$|$O(n^2)$|$O(n^2)$|$O(1)$|稳定
希尔|$O({n\log^2n})$|$O({n\log^2n})$|$O({n^2})$|$O(1)$|不稳定
快速|$O({n\log_2n})$|$O({n\log_2n})$|$O(n^2)$|$O({\log_2n})$|不稳定
堆|$O({n\log_2n})$|$O({n\log_2n})$|$O({n\log_2n})$|$O(1)$|不稳定
合并|$O({n\log_2n})$|$O({n\log_2n})$|$O({n\log_2n})$|$O(n)$|稳定