# 存储引擎
## 常见存储引擎
1. InnoDB: 是事务型存储引擎，只支持事务。MySQL 5.5 版本后默认的存储引擎为 InnoDB
2. MyISAM: MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎

## MyISAM 与InnoDB的区别
1. MyISAM 不支持**行级锁**，因此在并发写的时候，性能不好。
2. MyISAM 不支持**事务**；InnoDB 支持事务，具有提交(commit)和回滚(rollback)事务的能力。
3. MyISAM 不支持**外键**，而 InnoDB 支持。
4. MyISAM 不支持**数据库异常崩溃后的安全恢复**，而 InnoDB 支持。
5. MyISAM 不支持**MVCC**，而 InnoDB 支持。

# 锁机制与 InnoDB 锁算法
## 表级锁和行级锁对比
- 表级锁：MySQL 中锁定**粒度最大**的一种锁，加锁快，不会出现死锁，触发锁冲突的概率最高，并发度最低。
- 行级锁：MySQL 中锁定**粒度最小**的一种锁，能大大减少数据库操作的冲突，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。

## InnoDB 存储引擎的锁算法
- Record lock：记录锁，单个行记录上的锁
- Gap lock：间隙锁，锁定一个范围，不包括记录本身
- Next-key lock：record+gap 临键锁，锁定一个范围，包含记录本身

# 事务
## 定义
事务是逻辑上的一组操作，要么都执行，要么都不执行。平时谈论事务的时候，如果没有特指**分布式事务**，往往指的就是**数据库事务**，如果一个项目属于**单体架构**的话，使用的往往就是就是**数据库事务**。

## 事务的四大特性(ACID)
- 原子性(Atomicity):  事务是最小的执行单位，不允许分割。**InnoDB引擎**使用**undo log(回滚日志)**来保证事务的**原子性。**
- 一致性(Consistency): 执行事务前后，数据保持一致。
- 隔离性(Isolation): 各并发事务之间数据库是独立的。**InnoDB引擎**通过**锁机制、MVCC**等手段来保证事务的**隔离性。**
- 持久性(Durability): 一个事务被提交之后。它对数据库中数据的改变是持久的。**InnoDB引擎**使用**redo log(重做日志)**保证事务的**持久性。**
- **保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。**

## 并发事务带来的问题
- 脏读(Dirty read)
- 丢失修改(Lost to modify)
- 不可重复读(Unrepeatable read)
- 幻读(Phantom read)

## 事务隔离级别
隔离级别|脏读|不可重复读|幻读|含义
:-----:|:--:|:-------:|:--:|:--
读取未提交|&check;|&check;|&check;|最低的隔离级别，允许读取尚未提交的数据变更
读取已提交|&cross;|&check;|&check;|允许读取并发事务已经提交的数据
可重复读|&cross;|&cross;|&check;|对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改
可串行化|&cross;|&cross;|&cross;|最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行

# [MySQL高性能优化规范](https://www.cnblogs.com/huchong/p/10219318.html)

# MySQL 索引
## 索引的优缺点
优点: 
1. 可以大大加快数据的检索**速度**
2. 通过创建唯一性索引，可以保证数据库表中每一行数据的**唯一性**

缺点: 
1. 创建索引和维护索引需要耗费许多时间。
2. 索引需要使用物理文件存储，也会耗费一定空间。

## 索引的底层数据结构
### Hash
解决哈希冲突的办法:
1. 拉链法(链地址法):
   假定表T包含M个散列地址T[0]，T[l]，…，T[M-l]，拉链就是令散列地址等于i的记录组成一个链表，且指针T[i]是该单链表的头指针。
2. 线性探查:
   线性探查完全废除链接，以固定的次序检索表中的结点，直到找到一个关键词为K的结点或者找到一个空缺位置。

为什么 MySQL 没有使用Hash作为索引的数据结构:
1. Hash 冲突问题
2. Hash 索引不支持**顺序**和**范围**查询

### B 树， B+树
详见[二叉搜索树](../Data%20Structure%20and%20Algorithm/Binary_Search_Tree.md)

## 索引类型
### 按字段特性分类:
1. 主键索引: 数据表的主键列使用的就是主键索引，一张数据表有只能有一个主键，并且主键不能为 null，不能重复。
2. 唯一索引: 建立在UNIQUE字段上的索引被称为唯一索引，一张表可以有多个唯一索引，索引列值允许为 null，不能重复。
3. 普通索引: 建立在普通字段上的索引被称为普通索引。
4. 前缀索引: 前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。
唯一索引，普通索引，前缀索引等索引属于二级索引。

### 按物理存储分类:
1. 聚集索引: 聚集索引即索引结构和数据一起存放的索引，主键索引属于聚集索引。
2. 非聚集索引: 非聚集索引即索引结构和数据分开存放的索引，二级索引属于非聚集索引。

聚集索引的优点:
* 聚集索引利用B+树实现，查询速度非常快。

聚集索引的缺点:
* 依赖于有序的数据: 如果索引的数据不是有序的，那么就需要在插入时排序。
* 更新代价大: 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚集索引的叶子节点还存放着数据，修改代价肯定是较大的。

非聚集索引的优点:
* 更新代价比聚集索引要小，因为非聚集索引的叶子节点不存放数据。

非聚集索引的缺点:
* 跟聚集索引一样，非聚集索引也依赖于有序的数据。
* **可能会二次查询(回表)**，当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。

### 按字段个数分类:
1. 单列索引: 建立在单个列上的索引被称为单列索引。
2. 联合索引: 建立在多个列上的索引被称为联合索引，又叫复合索引、组合索引。

### 覆盖索引
覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。**主键索引**就是一种覆盖索引，如果某一非聚集索引是覆盖索引，就不用担心会发生回表查询的情况。

## 索引下推
一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。

## 最左前缀匹配原则
在使用联合索引时，MySQL 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据。  
在使用联合索引时，可以将**区分度高**的字段放在最左边，这也可以过滤更多数据。
